#!/usr/bin/env bash
# ======================================================================
# prune-old-releases.sh â€” Remove old preemptive releases while preserving vendored ones
#
# This script identifies and removes old releases that are no longer needed,
# while preserving all vendored releases and keeping only the most recent
# preemptive releases based on the configured preemptive_count.
#
# The script reuses the same logic and data structures as build-matrix.sh
# for consistency and maintainability.
#
# Input:
#   - configs.json            Language-keyed JSON object: { "<lang>": [ {name, repo, vcs, ...} ] }
#   - ebuild_registry.json    Generated by generate_ebuild_index.py
#
# Output:
#   - Deletes old releases via GitHub API
#   - Logs all actions taken
#
# Usage:
#   ./prune-old-releases.sh configs.json ebuild_registry.json
#
# Requires:
#   - bash 4+
#   - jq
#   - gh
#   - GITHUB_TOKEN environment variable
# ======================================================================
set -Eeuo pipefail

UTILS_LIB_ROOT="$(cd -P -- "$(dirname "${BASH_SOURCE[0]}")/../scripts/lib" && pwd)"

source "${UTILS_LIB_ROOT}/utils.lib.sh"

utils::load_or_die logging.lib.sh
logging::init "$0"

usage() {
  cat << SPRING_CLEANING
Usage: $(basename "$0") <configs.json> <ebuild_registry.json>

  configs.json            Language-keyed JSON object: { "go": [ {name, repo, vcs, ...} ], ... }
  ebuild_registry.json    Registry JSON with vendored versions

Environment:
  GITHUB_TOKEN           GitHub token for API access
  GITHUB_REPOSITORY      Repository in owner/repo format (optional, will detect from git)

SPRING_CLEANING
  exit 1
}

# Parses the config and validates input arguments
parse_args() {
  (($# == 2)) || {
    logging::log_error "Invalid number of args parsed"
    usage
  }

  local config_file="$1"
  local registry_file="$2"

  for file in config_file registry_file; do
    if [[ ! -r ${!file} ]]; then
      logging::log_error "Missing ${!file}"
      usage
    fi
  done

  printf "%s %s\n" "$config_file" "$registry_file"
}

# Check required environment and tools
check_requirements() {
  local -a required_cmds=(jq gh)
  local -a missing_cmds=()

  for cmd in "${required_cmds[@]}"; do
    if ! command -v -- "${cmd}" &> /dev/null; then
      missing_cmds+=("${cmd}")
    fi
  done

  if ((${#missing_cmds[@]})); then
    logging::log_fatal "The following tools are not installed: ${missing_cmds[*]}. Please install them."
  fi

  # Check GitHub token
  if [[ -z ${GITHUB_TOKEN:-} ]]; then
    logging::log_fatal "GITHUB_TOKEN environment variable not set"
  fi
}

load_all_vendored_tags() {
  local -n _vendored_ref="$1"
  local file="$2"

  while IFS=$'\n' read -r entry; do
    [[ -n ${entry} ]] && _vendored_ref["${entry}"]=1
  done < <(
    jq -r '
      .[] | select(.repo != null and .repo != "")
      | .repo as $r
      | .language as $l
      | .versions[] | select(. != "9999")
      | "\($r)-\(.):\($l)"
    ' "$file"
  )

  logging::log_info "Loaded ${#_vendored_ref[@]} vendored entries"
}

# Get all releases for this repository
get_our_releases() {
  local -n releases_ref="$1"

  while IFS=$'\t' read -r tag_name published_at; do
    [[ -n ${tag_name} ]] && releases_ref["${tag_name}"]="$published_at"
  done < <(
    gh release list \
      --repo "${GITHUB_REPOSITORY}" \
      --limit 1000 \
      --json tagName,publishedAt \
      -q '.[] | [.tagName, .publishedAt] | @tsv'
  )

  logging::log_info "Found ${#releases_ref[@]} existing releases"
}

# Sort releases by version, newest first
sort_releases_by_version() {
  local -a release_list=("$@")

  # Extract versions and sort
  printf "%s\n" "${release_list[@]}" | while read -r full; do
    # Extract the version as the last hyphen-separated field
    version_part="${full##*-}"
    name="${full%-${version_part}}"

    local version
    if version="$(utils::extract_version "${version_part}" 2> /dev/null)"; then
      printf "%s\t%s-%s\n" "$version" "$name" "$version_part"
    fi
  done | sort -V -r -k1,1 | cut -f2
}

# Process a single package for pruning
prune_package_releases() {
  local lang="$1"
  local name="$2"
  local repo="$3"
  local -i preemptive_count="$4"
  local -n vendored_ref="$5"
  local -n all_releases_ref="$6"

  logging::log_info "Processing ${name} (preemptive_count: ${preemptive_count})"

  # Find all releases for this package
  local -a package_releases=() vendored_releases=() preemptive_releases=()
  local release_pattern="${name}-"

  for release_tag in "${!all_releases_ref[@]}"; do
    if [[ ${release_tag} == ${release_pattern}* ]]; then
      package_releases+=("${release_tag}")
    fi
  done

  if ((${#package_releases[@]} == 0)); then
    logging::log_info "No releases found for ${name}"
    return 0
  fi

  logging::log_info "Found ${#package_releases[@]} releases for ${name}"

  # Classify releases as vendored or preemptive
  for release_tag in "${package_releases[@]}"; do
    local version_part="${release_tag#${name}-}"
    local version

    if ! version="$(utils::extract_version "${version_part}" 2> /dev/null)"; then
      logging::log_warn "Skipping release with invalid version: ${release_tag}"
      continue
    fi

    local vendored_key="${repo}-${version}:${lang}"

    if [[ -n ${vendored_ref["${vendored_key}"]:-} ]]; then
      vendored_releases+=("${release_tag}")
      logging::log_info "Vendored release: ${release_tag}"
    else
      preemptive_releases+=("${release_tag}")
      logging::log_info "Preemptive release: ${release_tag}"
    fi
  done

  logging::log_info "${name}: ${#vendored_releases[@]} vendored, ${#preemptive_releases[@]} preemptive"

  # Keep all vendored releases (never delete these)
  if ((${#vendored_releases[@]} > 0)); then
    logging::log_info "Preserving ${#vendored_releases[@]} vendored releases for ${name}"
  fi

  # For preemptive releases, keep only the newest N based on preemptive_count
  if ((${#preemptive_releases[@]} > preemptive_count)); then
    local -a sorted_preemptive to_delete
    mapfile -t sorted_preemptive < <(sort_releases_by_version "${preemptive_releases[@]}")

    # Keep the first preemptive_count releases (newest)
    for ((i = preemptive_count; i < ${#sorted_preemptive[@]}; i++)); do
      to_delete+=("${sorted_preemptive[i]}")
    done

    logging::log_info "Will delete ${#to_delete[@]} old preemptive releases for ${name}"

    # Delete old preemptive releases
    for release_tag in "${to_delete[@]}"; do
      local published_date="${all_releases_ref[${release_tag}]}"
      logging::log_info "Deleting old preemptive release: ${release_tag} (published: ${published_date})"

      if gh release delete "${release_tag}" --repo "${GITHUB_REPOSITORY}" --cleanup-tag --yes; then
        logging::log_info "Successfully deleted ${release_tag}"
      else
        logging::log_error "Failed to delete ${release_tag}"
      fi
    done
  else
    logging::log_info "Keeping all ${#preemptive_releases[@]} preemptive releases for ${name} (within limit)"
  fi
}

prune_releases() {
  local config_file="$1"
  local vendored_ref="$2"
  local all_releases_ref="$3"

  while IFS=$'\t' read -r name repo vcs subdir preemptive_count lang; do
    [[ -z ${name} || -z ${repo} || -z ${vcs} || -z ${lang} ]] && {
      logging::log_warn "Skipping incomplete line: ${name} | ${repo} | ${vcs} | ${lang}"
      continue
    }

    # Default preemptive_count to 0 if not set
    preemptive_count="${preemptive_count:-0}"

    prune_package_releases \
      "${lang}" \
      "${name}" \
      "${repo}" \
      "${preemptive_count}" \
      "${vendored_ref}" \
      "${all_releases_ref}"
  done < <(
    jq -r '
        select(type == "object")
        | to_entries[]
        | select(.value != null and (.value | type) == "array")
        | .key as $lang
        | .value[]
        | [.name, .repo, .vcs, (.subdir // "."), (.preemptive_count // 0), $lang]
        | @tsv
      ' "${config_file}"
  )
}

# Entry point
main() {
  # Parse and validate args
  config_args="$(parse_args "$@")"
  read -r config_file registry_file <<< "${config_args}"

  # Check requirements
  check_requirements

  local -A vendored_tags all_releases

  # Load vendored tags from ebuild registry
  load_all_vendored_tags vendored_tags "${registry_file}"

  # Load all existing releases from our repo
  get_our_releases all_releases

  # Process each package for pruning
  logging::log_info "Starting release pruning process"
  prune_releases "${config_file}" vendored_tags all_releases

  logging::log_info "Release pruning completed"
}

# Only run if executed, not sourced
if ! (return 0 2> /dev/null); then
  main "$@"
fi
