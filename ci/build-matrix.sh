#!/usr/bin/env bash
# ======================================================================
# build-matrix.sh â€” Generate a CI matrix from unreleased Git tags
#
# This script reads a JSON config containing module info (name, repo, vcs),
# an ebuild registry JSON, and a list of already-released tags.
# Any vendored tags that haven't yet been released are collected into a
# JSON array suitable for CI.
#
# Config format now supports optional preemptive_count per package:
# [
#   {
#     "name": "glow",
#     "repo": "charmbracelet/glow",
#     "vcs": "https://github.com/charmbracelet/glow.git",
#     "preemptive_count": 2
#   }
# ]
#
# Input:
#   - configs.json            JSON array of { name, repo, vcs, preemptive_count? } objects
#   - released_tags.txt       One tag per line (already-released)
#   - ebuild_registry.json    Generated by generate_ebuild_index.py
#   - language                Language key to filter vendored packages
#
# Output:
#   - JSON array of unreleased, vendored {name, repo, vcs, tag} objects
#
# Usage:
#   ./build-matrix.sh configs.json released_tags.txt ebuild_registry.json go
#
# Requires:
#   - bash 4+
#   - jq
#   - gh
# ======================================================================
set -Eeuo pipefail

# Resolve path to this script (even if it's symlinked)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Path to the logging library
LOGGING_PATH="${SCRIPT_DIR}/../scripts/lib/logging.lib.sh"

# Check and source the logging library
if [[ -f ${LOGGING_PATH} ]]; then
  # shellcheck source=../scripts/lib/logging.lib.sh
  source "${LOGGING_PATH}"
  logging::init "${BASH_SOURCE[0]}"
else
  printf "Something went wrong sourcing the logging lib: %s\n" "${LOGGING_PATH}" >&2
  exit 1
fi

# Path to vendored-extraction helper
EXTRACT_VENDORED="${SCRIPT_DIR}/extract-vendored.sh"
if [[ ! -x ${EXTRACT_VENDORED} ]]; then
  logging::log_fatal "Cannot find or execute ${EXTRACT_VENDORED}"
fi

usage() {
  cat <<INTO_THE_MATRIX_NEO
Usage: $(basename "${0}") <configs.json> <released_tags.txt> <ebuild_registry.json> <language>

  configs.json            JSON array of { name, repo, vcs } objects
  released_tags.txt       One tag per line (already-released)
  ebuild_registry.json    Registry JSON with versions to vendor
  language                Language key to filter vendored packages

INTO_THE_MATRIX_NEO
  exit 1
}

# Parses the config and validates input arguments.
# Exits if file paths are missing or invalid.
parse_args() {
  (($# == 4)) || {
    logging::log_error "Invalid number of args parsed"
    usage
  }

  local config_file="${1}"
  local released_file="${2}"
  local registry_file="${3}"
  local language="${4@L}" # make sure the language is lowercase

  for file in config_file released_file registry_file; do
    if [[ ! -r ${!file} ]]; then
      logging::log_error "Missing ${!file}"
      usage
    fi
  done

  printf "%s %s %s %s\n" "${config_file}" "${released_file}" "${registry_file}" "${language}"
}

# Builds an associative array of tags we've already released,
# so we can skip them during matrix generation.
load_released_tags() {
  local array_name="${1}"
  local released_file="${2}"
  declare -n arr="${array_name}"
  arr=()

  while IFS=$'\n' read -r tag; do
    logging::log_info "Found tag: ${tag}"
    [[ -n ${tag} ]] && arr["${tag}"]=1
  done <"${released_file}"
}

# Loads the tags that are packaged in the ebuild repository.
load_vendored_tags() {
  local -n vendored_ref="${1}"
  local file="${2}"
  local lang="${3}"

  while IFS=$'\n' read -r entry; do
    [[ -n ${entry} ]] && vendored_ref["${entry}"]=1
  done < <("${EXTRACT_VENDORED}" "${file}" "${lang}")

  logging::log_info "Loaded ${#vendored_ref[@]} vendored entries for language '${lang}'"
}

# Fetch the latest <count> release tags from a git repo using graphql
get_release_tags() {
  local repo="${1}"
  local count="${2:-6}"
  local owner="${repo%%/*}"
  local name="${repo##*/}"

  if [[ -z ${owner} || -z ${name} || ${owner} =~ ${repo} ]]; then
    logging::log_error "Invalid repo string: '${repo}'"
    return 1
  fi

  # Define the GraphQL document
  gql="$(
    cat <<-'BASHING_GQL'
    query($owner: String!, $name: String!) {
      repository(owner: $owner, name: $name) {
        releases(first: $count) {
          nodes { tagName }
        }
      }
  }
BASHING_GQL
  )"

  # Fire off the request with raw-field (preserves newlines/quotes cleanly)
  gh api graphql \
    -f query="${gql}" \
    -f owner="${owner}" \
    -f name="${name}" \
    -F count="${count}" \
    -q '.data.repository.releases.nodes[].tagName'
}

# Fetches tags from the remote Git repo and filters out already released ones.
# Appends unreleased entries (as JSON) into the matrix array.
process_module() {
  local name="${1}"
  local repo="${2}"
  local vcs="${3}"
  local -i preemptive_count="${4}"
  local -n released="${5}"
  local -n matrix="${6}"
  local -n vendored="${7}"

  local -i fetch_count preemptive_added=0
  local -a raw_entries=() matrix_chunk=()

  logging::log_info "Checking tags for ${name} (preemptive_count: ${preemptive_count})"

  # Calculate how many tags to fetch: default 6, or preemptive+2 if asked
  ((fetch_count = preemptive_count > 0 ? preemptive_count + 2 : 6))

  # read remote tags into an array
  mapfile -t tags < <(get_release_tags "${repo}" "${fetch_count}")

  for tag in "${tags[@]}"; do
    check_tag="${name}-${tag}" # Add name to tag to match what's in the released array

    # Skip if empty or already released
    [[ -z ${check_tag} || -n ${released["${check_tag}"]:-} ]] && continue

    # Check if this tag is in the vendored list (1 = yes, 0 = no)
    local -i is_vendored=0
    [[ -n ${vendored["${check_tag}"]:-} ]] && is_vendored=1

    # Decide whether to build this tag (1 = yes, 0 = no)
    local -i should_build=0
    local build_reason=""

    if ((is_vendored)); then
      should_build=1
      build_reason="vendored"
    elif ((preemptive_count > 0 && preemptive_added < preemptive_count)); then
      should_build=1
      build_reason="preemptive"
      ((++preemptive_added))
    fi

    if ((should_build)); then
      # emit a tiny JSON object with unescaped shell strings
      # (jq handles escaping later)
      raw_entries+=(
        "$(printf '{"tag":"%s","build_type":"%s"}' \
          "${tag}" "${build_reason}")"
      )
      logging::log_info "Added ${build_reason} build for ${name}:${tag}"
    fi
  done

  if ((${#raw_entries[@]})); then
    # join them with newlines and hand them off to jq in one go
    mapfile -t matrix_chunk < <(
      printf '%s\n' "${raw_entries[@]}" \
        | jq -cs --arg name "$name" \
          --arg repo "$repo" \
          --arg vcs "$vcs" \
          ' map(fromjson)
        | map(. + {name:$name, repo:$repo, vcs:$vcs})
        | .[] | @json'
    )

    # now append each JSON-proper string
    matrix+=("${matrix_chunk[@]}")
  fi
}

# iterate over configs.json
build_matrix() {
  local config_file="${1}"
  local released_ref="${2}"
  local matrix_ref="${3}"
  local vendored_ref="${4}"

  # Use nameref to mutate the release array
  local -n released="${released_ref}"

  while IFS=$'\t' read -r name repo vcs preemptive_count; do
    [[ -z ${name} || -z ${repo} || -z ${vcs} ]] && {
      logging::log_warn "Skipping incomplete line: ${name} | ${repo} | ${vcs}"
      continue
    }

    # make sure preemptive_count is set to 0 by default
    preemptive_count="${preemptive_count:-0}"

    process_module \
      "${name}" \
      "${repo}" \
      "${vcs}" \
      "${preemptive_count}" \
      "${released_ref}" \
      "${matrix_ref}" \
      "${vendored_ref}"
  done < <(
    jq -r '.[] | [.name, .repo, .vcs, (.preemptive_count // 0)] | @tsv' \
      "${config_file}"
  )
}

# Entry point
main() {
  # Parse and validate args
  config_args="$(parse_args "$@")"
  read -r config_file released_file registry_file language <<<"${config_args}"

  declare -A released_tags
  declare -A vendored_tags
  declare -a matrix_entries

  # Load already downloaded release tags
  load_released_tags released_tags "${released_file}"

  # Load versions to vendor from ebuild repo
  load_vendored_tags vendored_tags "${registry_file}" "${language}"

  # Build matrix json array
  build_matrix "${config_file}" released_tags matrix_entries vendored_tags

  printf '%s\n' "${matrix_entries[@]}" | jq -s -c .
}

# Make sure main is only ran if executed and not
# if it is sourced.
if ! (return 0 2>/dev/null); then
  main "$@"
fi
