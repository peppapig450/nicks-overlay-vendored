#!/usr/bin/env bash
# ======================================================================
# build-matrix.sh â€” Generate a CI matrix from unreleased Git tags
#
# This script reads a JSON config structured by language, where each key maps
# to an array of module objects (name, repo, vcs, preemptive_count?), an ebuild
# registry JSON, and a list of already-released tags. Any vendored tags that
# haven't yet been released are collected into a JSON array suitable for CI.
#
# Example of what configs.json should look like:
# {
#  "go": [
#    {
#      "name": "glow",
#      "repo": "charmbracelet/glow",
#      "vcs": "https://github.com/charmbracelet/glow.git",
#      "preemptive_count": 2
#    }
#  ],
#  "rust": [
#    {
#      "name": "some-crate",
#      "repo": "user/some-crate",
#      "vcs": "https://github.com/user/some-crate.git"
#    }
#  ]
# }
#
#
# Input:
#   - configs.json            Language-keyed JSON object: { "<lang>": [ {name, repo, vcs, ...} ] }
#   - released_tags.txt       One tag per line (already-released)
#   - ebuild_registry.json    Generated by generate_ebuild_index.py
#
# Output:
#   - JSON array of unreleased, vendored {name, repo, vcs, tag, language} objects
#
# Usage:
#   ./build-matrix.sh configs.json released_tags.txt ebuild_registry.json
#
# Requires:
#   - bash 4+
#   - jq
#   - gh
# ======================================================================
set -Eeuo pipefail

# Resolve path to this script (even if it's symlinked)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Path to the logging library
LOGGING_PATH="${SCRIPT_DIR}/../scripts/lib/logging/logging.lib.sh"

# Check and source the logging library
if [[ -f ${LOGGING_PATH} ]]; then
  # shellcheck source=../scripts/lib/logging/logging.lib.sh
  source "${LOGGING_PATH}"
  logging::init "${BASH_SOURCE[0]}"
else
  printf "Something went wrong sourcing the logging lib: %s\n" "${LOGGING_PATH}" >&2
  exit 1
fi

usage() {
  cat << INTO_THE_MATRIX_NEO
Usage: $(basename "${0}") <configs.json> <released_tags.txt> <ebuild_registry.json>

  configs.json            Language-keyed JSON object: { "go": [ {name, repo, vcs, ...} ], ... }
  released_tags.txt       One tag per line (already-released)
  ebuild_registry.json    Registry JSON with versions to vendor

INTO_THE_MATRIX_NEO
  exit 1
}

# Parses the config and validates input arguments.
# Exits if file paths are missing or invalid.
parse_args() {
  (($# == 3)) || {
    logging::log_error "Invalid number of args parsed"
    usage
  }

  local config_file="${1}"
  local released_file="${2}"
  local registry_file="${3}"

  for file in config_file released_file registry_file; do
    if [[ ! -r ${!file} ]]; then
      logging::log_error "Missing ${!file}"
      usage
    fi
  done

  printf "%s %s %s\n" "${config_file}" "${released_file}" "${registry_file}"
}

# Builds an associative array of tags we've already released,
# so we can skip them during matrix generation.
load_released_tags() {
  local array_name="${1}"
  local released_file="${2}"
  declare -n arr="${array_name}"
  arr=()

  while IFS=$'\n' read -r tag; do
    logging::log_info "Found tag: ${tag}"
    [[ -n ${tag} ]] && arr["${tag}"]=1
  done < "${released_file}"
}

# Loads the tags that are packaged in the ebuild repository.
load_all_vendored_tags() {
  local -n vendored_ref="${1}"
  local file="${2}"

  while IFS=$'\n' read -r entry; do
    [[ -n ${entry} ]] && vendored_ref["${entry}"]=1
  done < <(
    jq -r '
      .[] | select(.repo != null and .repo != "")
      | .repo as $r
      | .language as $l
      | .versions[] | select(. != "9999")
      | "\($r)-\(.):\($l)"
    ' "${file}"
  )

  logging::log_info "Loaded ${#vendored_ref[@]} vendored entries"
}

# Fetch the latest <count> release tags from a git repo using graphql
get_release_tags() {
  local repo="${1}"
  local count="${2:-6}"
  local owner="${repo%%/*}"
  local name="${repo##*/}"

  if [[ -z ${owner} || -z ${name} || ${owner} =~ ${repo} ]]; then
    logging::log_error "Invalid repo string: '${repo}'"
    return 1
  fi

  # Define the GraphQL document
  gql="$(
    cat <<- 'BASHING_GQL'
    query($owner: String!, $name: String!, $count: Int!) {
      repository(owner: $owner, name: $name) {
        releases(first: $count) {
          nodes { tagName }
        }
      }
  }
BASHING_GQL
  )"

  # Fire off the request with raw-field (preserves newlines/quotes cleanly)
  gh api graphql \
    -f query="${gql}" \
    -f owner="${owner}" \
    -f name="${name}" \
    -F count="${count}" \
    -q '.data.repository.releases.nodes[].tagName'
}

# Fetches tags from the remote Git repo and filters out already released ones.
# Appends unreleased entries (as JSON) into the matrix array.
process_module() {
  local lang="$1"
  local name="$2"
  local repo="$3"
  local vcs="$4"
  local -i preemptive_count="$5"
  local -n released="$6"
  local -n matrix="$7"
  local -n vendored="$8"

  local -i fetch_count preemptive_added=0
  local -a raw_entries=() matrix_chunk=()

  logging::log_info "Checking tags for ${name} (preemptive_count: ${preemptive_count})"

  # Calculate how many tags to fetch: default 6, or preemptive+2 if asked
  ((fetch_count = preemptive_count > 0 ? preemptive_count + 2 : 6))

  # read remote tags into an array
  mapfile -t tags < <(get_release_tags "${repo}" "${fetch_count}")

  for tag in "${tags[@]}"; do
    local check_name_tag="${name}-${tag}" # Add name to tag to match what's in the released array
    local check_repo_tag="${repo}-${tag}" # Tag used for vendored lookup

    # Skip if empty or already released
    [[ -z ${check_name_tag} || -n ${released["${check_name_tag}"]:-} ]] && continue

    # Check if this tag is in the vendored list (1 = yes, 0 = no)
    local -i is_vendored=0
    [[ -n ${vendored["${check_repo_tag}"]:-} ]] && is_vendored=1

    # Decide whether to build this tag (1 = yes, 0 = no)
    local -i should_build=0
    local build_reason=""

    if ((is_vendored)); then
      should_build=1
      build_reason="vendored"
    elif ((preemptive_count > 0 && preemptive_added < preemptive_count)); then
      should_build=1
      build_reason="preemptive"
      ((++preemptive_added))
    fi

    if ((should_build)); then
      # emit a tiny JSON object with unescaped shell strings
      # (jq handles escaping later)
      local entry
      printf -v entry \
        '{"tag":"%s","language":"%s","build_type":"%s"}' \
        "${tag}" "${lang}" "${build_reason}"

      raw_entries+=("${entry}")
      logging::log_info "Added ${build_reason} build for ${name}:${tag}"
    fi
  done

  if ((${#raw_entries[@]})); then
    # join them with newlines and hand them off to jq in one go
    mapfile -t matrix_chunk < <(
      printf '%s\n' "${raw_entries[@]}" \
        | jq -cs --arg name "$name" \
          --arg repo "$repo" \
          --arg vcs "$vcs" '
          map(. + {name:$name, repo:$repo, vcs:$vcs})
          | .[]
        '
    )

    # now append each JSON-proper string
    matrix+=("${matrix_chunk[@]}")
  fi
}

# iterate over configs.json
build_matrix() {
  local config_file="${1}"
  local released_ref="${2}"
  local matrix_ref="${3}"
  local vendored_ref="${4}"

  while IFS=$'\t' read -r name repo vcs preemptive_count lang; do
    [[ -z ${name} || -z ${repo} || -z ${vcs} || -z ${lang} ]] && {
      logging::log_warn "Skipping incomplete line: ${name} | ${repo} | ${vcs} | ${lang}"
      continue
    }

    # make sure preemptive_count is set to 0 by default
    preemptive_count="${preemptive_count:-0}"

    process_module \
      "${lang}" \
      "${name}" \
      "${repo}" \
      "${vcs}" \
      "${preemptive_count}" \
      "${released_ref}" \
      "${matrix_ref}" \
      "${vendored_ref}"
  done < <(
    jq -r '
        select(type == "object")
        | to_entries[]
        | select(.value != null and (.value | type) == "array")
        | .key as $lang
        | .value[]
        | [.name, .repo, .vcs, (.preemptive_count // 0), $lang]
        | @tsv
      ' "${config_file}"
  )
}

# Entry point
main() {
  # Parse and validate args
  config_args="$(parse_args "$@")"
  read -r config_file released_file registry_file <<< "${config_args}"

  local -A released_tags
  local -A vendored_tags
  local -a matrix_entries

  # Load already downloaded release tags
  load_released_tags released_tags "${released_file}"

  # Load versions to vendor from ebuild repo
  load_all_vendored_tags vendored_tags "${registry_file}"

  # Build matrix json array
  build_matrix "${config_file}" released_tags matrix_entries vendored_tags

  printf '%s\n' "${matrix_entries[@]}" | jq -s -c .
}

# Make sure main is only ran if executed and not
# if it is sourced.
if ! (return 0 2> /dev/null); then
  main "$@"
fi
